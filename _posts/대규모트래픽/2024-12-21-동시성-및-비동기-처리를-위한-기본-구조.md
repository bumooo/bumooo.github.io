---
title: "동시성 및 비동기 처리를 위한 기본 구조"
author: bumoo
date: 2024-12-21 18:51:00 +0900
categories: ["대규모 트래픽"]
tags: [동시성, 비동기]
---

## 스레드 풀(Thread Pool)
- 미리 생성된 스레드의 집합
- 작업이 들어올 때마다 새로운 스레드를 생성하지 않고, 생성된 스레드를 재사용하여 작업 처리
- 스레드 생성 및 소멸에 따른 오버헤드를 줄이고, 동시성 처리에 자원을 효율적으로 관리

## 스레드 풀의 구조 및 특징
![스레드 풀](https://github.com/user-attachments/assets/d9254f04-ea30-4e60-8724-5875ec83b695)
- 여러 작업을 동시에 처리하기 위해 미리 생성된 스레드의 집합을 유지
- 작업 요청시 사용 가능한 스레드에 할당
- 스레드 작업 완료시 다른 작업에 할당되기 전까지 대기 상태
- 스레드 풀의 적절한 크기 설정 필요
  - 작은 경우 처리량 제한
  - 큰 경우 CPU, 메모리가 과도하게 사용

## 스레드 풀 사용시 고려 사항
1. 스레드 풀의 크기 : 작으면 처리량 제한, 크면 자원을 과하게 사용
2. 작업 종류 : CPU 집약 작업, IO 집약 작업 등 작업 종류에 따라 설정
3. 스레드 생성과 파괴 비용
4. 메모리 사용량 : 각 스레드는 스택 메모리를 가지므로, 스레드를 많이 생성할 수록 메모리가 많이 사용
5. 동기화 문제 : 공유 자원 접근시 동기화 문제가 발생하므로 동기화 메커니즘을 적절히 사용하지 않으면 성능이 떨어짐
6. 응답 시간과 처리량

## 비동기 처리와 이벤트 루프(Event Loop)
![이벤트 루프](https://github.com/user-attachments/assets/f6847301-5641-431f-974b-7628ecb99254)
- 이벤트 루프는 비동기 처리를 위한 구조로, 하나의 스레드가 여러 작업을 순차적으로 처리하는 방식
- I/O 작업에 효율적
- 단일 스레드 기반으로 동작, 비동기 작업이 완료될 때마다 이벤트 큐에 있는 작업 처리


## 이벤트 루프가 입출력 작업에 적합한 이유
1. 논블로킹(Non-Blocking) I/O 모델
2. 효율적 자원 사용
3. 반응성 유지

## 비동기 작업의 오류 처리 및 콜백 패턴
콜백 패턴(Callback Pattern)
- 비동기 작업이 완료된 후 실행될 작업을 미리 등록해 두는 방식
- 단순하고, 효율적이지만 콜백 지옥이라 불리는 복잡한 구조가 될 수 있음

## Java의 비동기 API 디자인 패턴
`CompletableFuture`
- 비동기 작업의 결과를 비동기적으로 처리할 수 있는 Java API
- JS의 Promise와 유사하며, 비동기 작업 완료시 그 결과를 사용해 후속 작업 정의 가능

## 비동기 처리시 유의사항
스레드 안전성(Thread Safety)
- 스레드가 공유 자원에 접근시 적절한 동기화 메커니즘을 사용 ex) `synchronized`

예외 처리 필요
- 비동기 처리시 예외가 발생한 경우 처리가 필요 ex) `CompletableFuture의 exceptionally()`







