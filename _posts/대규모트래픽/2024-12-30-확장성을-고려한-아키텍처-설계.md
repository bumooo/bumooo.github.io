---
title: "확장성을 고려한 아키텍처 설계의 실제 사례와 전략"
author: bumoo
date: 2024-12-30 16:35:00 +0900
categories: ["대규모 트래픽"]
tags: ["대규모 트래픽", "아키텍처"]
---


## Monolithic 소규모 쇼핑몰에서 대형 쇼핑몰로 발전

### 1단계 : Monolithic 아키텍처
![Monolithic 아키텍처](https://github.com/user-attachments/assets/00ca3755-7f0e-430f-8d99-d5d2d9bed0af)

모든 기능이 하나의 코드베이스에 포함되어 실행

장점
- 개발이 쉽고, 초기 리소스가 적게 들어가 유지보수 간편
   
단점
- 트래픽이 적을 땐 괜찮지만, 사용자가 증가할수록 시스템 성능이 떨어짐

### 2단계 : 수직 확장
![수직 확장](https://github.com/user-attachments/assets/8d5153af-ca98-4743-ab16-a25a317dfc74)
CPU, 메모리, 디스크 용량 등을 올려 성능 업그레이드

한계점
- 물리적 한계가 도달하여 서버 성능 업그레이드를 하지 못해 트래픽 감당이 불가능할 수 있음 

### 3단계 : 수평 확장
![수평 확장](https://github.com/user-attachments/assets/be1de73c-013d-4fa8-bc7a-0833123c60ba)
로드 밸런서를 사용해 사용자 요청을 여러 대의 서버로 분산하는 다중 서버 구조 전환

장점
- 트래픽에 따라 서버를 유연하게 추가, 제거하여 확장성 제공
- 하나의 서버가 장애가 나도 다른 서버가 계속 운영하여 가용성 높임

### 4단계 : 데이터베이스 분산 및 샤딩
서버는 분산되었지만, 데이터베이스는 한 대에서 모든 트랜잭션을 처리하기 때문에 성능 저하 발생

샤딩 도입
- 데이터를 여러 개의 샤드로 분리하여, 각 샤드가 독립적으로 데이터 처리

### 5단계 : 캐싱 적용
![캐싱 적용](https://github.com/user-attachments/assets/ef0088ce-2f97-4664-b63d-f5b7e234cd7f)
대규모 사용자가 동시에 접속할 때, 자주 조회되는 데이터를 데이터베이스에서 조회하는 대신 캐시에 저장하여 빠르게 응답

캐싱을 통해 데이터베이스에 대한 요청이 크게 줄고 빠르게 응답

### 6단계 : 마이크로서비스 도입
![마이크로 서비스](https://github.com/user-attachments/assets/6454e5c2-1921-4901-9325-d19b0bd59194)
**Monolithic 구조의 한계**
- 구조는 복잡해지고, 기능별로 독립적인 확장과 배포가 어려움

마이크로서비스 전환
- 기능을 독립적인 서비스로 분리하여 운영
- 서비스 간의 통신은 API 통해 이뤄짐

장점
- 독립적으로 배포, 확장될 수 있어 유연성 증가
- 특정 기능에 트래픽이 몰릴 경우, 해당 기능만 확장 가능

### 7단계 : 비동기 이벤트 처리 도입
![비동기 이벤트 처리](https://github.com/user-attachments/assets/011e4cc0-6ad8-4535-af99-174007162bf5)
주요 트랜잭션이 완료된 후 시간이 걸리는 작업은 메시지 큐로 전달하여 처리

장점
- 메인 프로세스의 성능을 유지하면서, 시간이 걸리는 작업은 나중에 처리하여 응답성을 높이고 시스템 효율적으로 운영

## 오버엔지니어링을 피해야 하는 이유
불필요한 복잡성 증가
- MSA, 비동기 처리 같은 복잡한 구조를 적용하면 트래픽이 적은 시점에 관리와 운영이 과도하게 복잡해짐
- 시스템의 성능 보장보다 개발과 배포 속도을 늦추고 개발 리소스 낭비

비용과 리소스 낭비
- MSA, 비동기 처리를 적용하는 데 필요한 인프라 비용과 개발 시간 낭비

## 시스템 상태에 맞는 구조 선택
단계적 확장
- Monolithic 구조에서 수평 확장, 데이터베이스 샤딩, 캐싱, MSA 등으로 전환

필요에 따라 확장
- 서비스가 성장할 때 필요한 부분만 비동기 처리, 특정 기능만 MSA 분리하는 것이 좋음

지나친 최적화 경계
- 지나친 아키텍처 최적화를 시도하면 나중에 수정이 어려워짐
- 기술 부채를 최소화하고, 서비스 요구에 맞춰 단계별로 아키텍처 선택이 필요


