---
title: "아이템84 : 프로그램의 동작을 스레드 스케줄러에 기대지 말라"
author: bumoo
date: 2023-06-24 19:54:00 +0900
categories: [이펙티브 자바]
tags: [이펙티브 자바]
---

## 이식성 좋은 프로그램

여러 스레드가 실행 중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 실행할지 정한다.

잘 작성된 프로그램이라면 스케줄링 정책에 좌지우지돼서는 안된다.

정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하지 어렵다.

이식성 좋은 프로그램을 작성하는 가장 좋은 방법은 실행 가능한 스레드의 평균적인 수를 프로세스 수보다 지나치게 많아지지 않도록 하는 것이다.

실행 가능한 스레드 수를 적게 유지하는 기법은 각 스레드가 무언가 유용한 작업을 완료한 후에 다음 일거리가 생길 때까지 대기하도록 하는 것이다.

**스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안된다.**

예로, 스레드 풀 크기를 적절히 설정하고 작업을 짧게 유지하면 된다. 단, 너무 짧으면 작업을 분배에 부담이 성능을 떨어뜨릴 수 있다.

## 바쁜 대기

스레드는 절대 바쁜 대기(`busy waiting`) 상태가 되면 안된다. 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다.

바쁜 대기는 스케줄의 변덕에 취약하고, 프로세스에 큰 부담이 되어 유용한 작업이 실행될 기회를 박탈한다.

```java
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0)
            throw new IllegalArgumentException(count + " < 0")l
        this.count = count;
    }

    public void await() {
        while (true) {
            synchronized(this) {
                if (count == 0)
                    return;
            }
        }
    }

    public synchronized void countDown() {
        if (count != 0) {
            count--;
        }
    }
}
```
위의 예시는 `CountDownLatch`의 바쁜대기 버전이고, `CountDownLatch`보다 성능이 느리다.

하나 이상의 스레드가 필요도 없이 실행 가능한 상태인 시스템은 흔하게 볼 수 있다. 이런 시스템은 성능과 이식성이 떨어진다.

## Thread.yield

특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해 간신히 돌아가는 프로그램을 보더라도 `Thread.yield`를 써서 고치려하지 말자.

증상은 호전되더라도 이식성은 그렇지 않다. 처음 JVM에선 성능을 올려주고, 다음은 효과가 없고, 다음은 성능이 악화될 수 있다.

추가로 `Thread.yield`는 테스트할 수단도 없다.

**차라리 애플리케이션 구조를 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치하자.**
