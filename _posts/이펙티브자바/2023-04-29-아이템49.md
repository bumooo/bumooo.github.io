---
title: "아이템49 : 매개변수가 유효한지 검사하라"
author: bumoo
date: 2023-04-29 20:46:00 +0900
categories: [이펙티브 자바]
tags: [이펙티브 자바]
---

## 메소드의 매개변수 검사

메소드와 생성자는 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.

제약은 반드시 문서화해야 하며 메소드 몸체가 시작되기 전에 검사해야 한다. **오류는 가능한 빨리 잡아야 한다.**

오류는 즉시 잡지 못하면 오류 감지가 어렵고, 발생 지점을 찾기 어렵다.

매개변수 검사를 제대로 하지 못하면 문제가 있다.

### 메소드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.

더 나쁜 상황은 메소드가 수행되지만 잘못된 결과를 반환하는 것이다.

더 않 좋은 상황은 어떤 객체를 이상한 상태로 만들어 미래의 알 수 없는 시점에 이 메소드와 관련 없는 오류를 낼 때다.

매개변수 검사에 실패하면 **실패 원자성**을 어기는 결과를 낳을 수 있다.

`public`, `protected` 메소드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. 제약을 어겼을 때 발생하는 예외도 함께 문서화해야 한다.

```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메소드는
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메소드와 다르다.
 * 
 * @Param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @thorws ArtimeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0)
        throw new ArtimeticException("계수(m)는 양수여야 합니다. " + m);
    ... // 계산 수행
}
```

m이 `null`이면 `m.signum`에서 `NullPointException`을 던진다. 하지만 메소드 설명엔 존재하지 않는다.

그 이유는 `BigInteger` 수준에서 기술했기 때문이다.

## Objects의 유효성 검사 메소드

또한 자바 7에 추가된 `java.util.Objects.requireNonNull` 메소드는 유연하고 사용하기 편하니 더 이상 `null 검사`를 수동으로 하지 않아도 된다.

추가로 예외 메시지도 지정할 수 있다.

```java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

반환값은 무시하고, 순수한 `null 검사` 목적으로 사용해도 된다.

자바 9에서는 범위 검사 기능도 추가됐다. `checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 메소드이다.

`null 검사`보다는 유연하지 않다. 예외 메시지를 지정할 수 없고, 리스트와 배열 전용으로 설계됐다. 또한 닫힌 범위는 다루지 못한다.

> 닫힌 범위 : 양 끝단 값을 포함
{: .prompt-info }

## Assert을 통한 유효성 검사

공개되지 않은 메소드라면 상황을 통제할 수 있다.

오직 유효한 값만이 메소드에 넘겨지리라는 것을 보증할 수 있어야 한다. `assert`(단언문)을 사용해 매개변수 유효성을 검증할 수 있다.

```java
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    ... // 계산 수행
}
```

단언문은 모두 참이라고 선언하는 것이다. 단언문은 일반적인 유효성 검사와 다르다.

1. 실패하면 `AssertionException`을 던진다.
2. 런타임에 아무런 효과도, 성능 저하도 없다.

## 나중에 사용하기 위한 매개변수

메소드가 직접 사용하지 않으나, 나중에 쓰기 위해 저장하는 매개변수는 더 신경써야 한다.

메소드에서 검사하지 않으면, 클라이언트가 돌려 받은 객체를 사용하려 할 때 오류가 발생한다.

이렇게 되면, 어디서 발생하는지 추적이 어렵다.

생성자는 **나중에 쓰기 위해 저장하는 매개변수의 유효성을 검사하라**는 원칙의 특수한 사례다.

생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다.

## 암묵적 유효성 검사

메소드 몸체 실행 전에 매개변수 유효성을 검사해야 한다는 규칙에 예외도 있다.

예외는 유효성 검사 비용이 지나치게 높거나, 실용적이지 않을 때 또는 암묵적으로 검사가 수행될 때다.

예를 들어 `Collections.sort(List)`가 있다. 리스트 안의 객체들은 모두 상호 비교될 수 있어야 한다. 만약 비교할 수 없는 객체라면 `ClassCastException`을 던진다.

여기서 리스트에 상호 비교가 가능한 객체만 있는지 검사는 실익이 없다.

하지만 암묵적 유효성 검사에 너무 의존하면 실패 원자성을 해칠 수 있다.

때로는 계산 과정에서 유효성 검사가 실패했을 때 잘못된 예외를 던질 수 있다.

계산 중 잘못된 매개변수을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다.
