---
title: "아이템15 : 클래스와 멤버의 접근 권한을 최소화하라"
author: bumoo
date: 2023-01-28 23:31:00 +0900
categories: [이펙티브 자바]
tags: [이펙티브 자바]
---


## 정보 은닉(캡슐화)의 장점
대부분 시스템을 구성하는 컴포넌트들을 서로 독립시켜서 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 해주는 것과 연관되어 있다.

1. 시스템 개발 속도를 높인다.
    - 여러 컴포넌트를 병렬로 개발할 수 있다.
2. 시스템 관리 비용을 낮춘다.
    - 각 컴포넌트를 빨리 파악하여, 디버깅이 가능하며, 다른 컴포넌트로 교체하는 부담도 적다.
3. 정보 은닉(캡슐화) 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
    - 다른 컴포넌트에 영향을 주지 않고, 해당 컴포넌트만 최적화할 수 있다.
4. 소프트웨어 재사용성을 높인다.
    - 외부의 의존 하지 않고, 독자적으로 동작하는 컴포넌트는 낯선 환경에서도 유용하게 사용 가능성이 높다.
5. 큰 시스템을 제작하는 난이도를 낮춰준다.
    - 아직 완성되지 않은 상태에서도 개별 컴포넌트 동작을 검증할 수 있다.

## 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.
자바는 정보 은닉을 위한 다양한 장치를 제공한다. 그 중 접근 제어 메커니즘은 클래스, 인터페이스, 멤버의 접근성을 명시한다.
접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다. 소프트웨어가 올바르게 동작하는 한 가장 낮은 접근 수준을 부여해야 한다.

톱 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 `default`, `public` 두 가지다.
`public`을 사용하면, 공개 API가 되고, `default`를 사용하면 해당 패키지 안에서만 이용할 수 있다.
`default`가 되면, 내부 구현이 되어 언제든지 수정이 가능하다. 클라이언트에 아무런 피해 없이 수정, 교체, 제거할 수 있다.
반면 `public`의 경우 API가 되므로 하위 호환을 위해 영원히 관리해야 한다.

→ `public`일 필요가 없는 클래스의 접근 수준을 `default`로 좁혀야 한다.


## 멤버(필드, 메소드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준

| 접근 제어자                      | 접근 범위         |
|:-----------------------------|:-----------------|
| `private`          |멤버를 선언한 톱레벨 클래스에서만 접근 가능 |
| `default`               |멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 |
| `protected` |`default`의 접근 범위를 포함하고, 상속을 한 하위 클래스에서도 접근 가능|
| `public` | 모든 곳에서 접근 가능 |

> 인터페이스에서 `default`는 `public`으로 적용된다.
{: .prompt-info }

클래스의 공개 API를 설계한 후, 그 외의 모든 멤버는 `private`로 설정한다. 상황에 따라 권한을 풀어 주는 작업을 한다.
공개 클래스에서 `default` → `protected`로 바꾸는 순간 대상 범위가 엄청 넓어진다. `public` 클래스의 `protected`는 공개 API이다.
따라서 `protected` 멤버가 적을수록 좋다.

## 멤버 접근성을 좁히지 못하게 하는 방해 제약
상위 클래스의 메소드를 재정의할 때(`Override`)는 접근 수준을 상위 클래스보다 좁게 설정할 수 없다. 
이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다(리스코프 치환 원칙)을 지키기 위해 필요하다. 
제약을 어기게 되면 컴파일 오류가 발생한다.

> 테스트 목적으로 접근 제어자를 `default`까지는 풀어도 되지만, 그 이상 풀지 않는 것을 권장한다.
{: .prompt-warning }

## public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
필드가 가변 객체를 참조하거나, `final`이 아닌 인스턴스 필드를 `public`으로 선언하면, 해당 필드에 담을 수 있는 값을 제한할 힘을 잃는다.
즉, 그 필드의 불변식을 보장할 수 없게 된다는 뜻이다.
또한 필드가 수정될 때(락 획득) 다른 작업을 할 수 없게 되므로 **`public` 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지 않다.**

## 정적 필드에서도 마찬가지이나, 예외인 경우
해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소러써의 상수라면 `public static final` 필드로 공개해도 좋다.
이런 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다. 가변 객체를 참조한다면 `final`이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다.
```java
final String[] NUMBERS = {"1", "2", "3"};
System.out.println(Arrays.toString(NUMBERS));
NUMBERS[0] = "10";
System.out.println(Arrays.toString(NUMBERS));
```

```text
[1, 2, 3]
[10, 2, 3]
```

위 코드 처럼 다른 객체를 참조는 못하지만, 참조된 객체 자체는 수정될 수 있다.
길이가 0이 아닌 배열은 모두 변경이 가능하다. 따라서 **가변 객체의 경우 `public static final` 필드로 두거나, 해당 필드를 반환하는 접근자 메서드를 제공해선 안된다.**

```java
public static final Thing[] VALUE = { ... };
```
`VALUE` 필드는 참조를 변경하진 못해도, 수정이 가능하다. 해결 방법은 아래 2가지가 있다.
```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = List.of(PRIVATE_VALUES);
```
`public`을 `private`로 변경 후에 `public`으로 불변 리스트를 추가하는 방법이다.

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```
`public`을 `private`로 변경 후에 그 복사본을 반환하는 `public` 메소드를 추가하는 방법(방어적 복사)이다.