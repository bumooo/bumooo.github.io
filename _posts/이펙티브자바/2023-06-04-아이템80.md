---
title: "아이템80 : 스레드보다는 실행자, 태스크, 스트림을 애용하라"
author: bumoo
date: 2023-06-04 02:03:00 +0900
categories: [이펙티브 자바]
tags: [이펙티브 자바]
---

## 실행자 프레임워크

`java.util.concurrent` 패키지가 등장했다. 이 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

```java
ExcutorService exec = Executors.newSingleThreadExecutor();
```

단 한줄로 작업 큐를 생성할 수 있다.

```java
exec.execute(runnable);
```

실행자에 실행할 태스크를 넘기는 방법이다.

```java
exec.shutdown();
```

실행자를 종료시키는 방법이다.

실행자 서비스의 기능은 이외에도 많다.

- 특정 태스크가 완료되기를 기다린다.(아이템79의 `get`)
- 태스크 모음 중 아무것 하나(`invokeAny`) 혹은 모든 태스크(`invokeAll`)가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.(`awaitTermination`)
- 완료된 태스크들의 결과를 차례로 받는다.(`ExecutorCompletionService` 이용)
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.(`ScheduledThreadPollExecutor` 이용)

## 상황에 맞는 실행자 서비스 선택

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 다른 정적 팩토리를 이용하여 다른 종류의 실행자 서비스(`ThreadPool`)를 생성하면 된다.

스레드 풀의 개수는 고정할 수도, 필요에 따라 늘이거나 줄어들게 설정할 수 있다.

`ThreadPollExecutor` 클래스를 직접 사용해도 된다. 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있다.

`Executors.newCachedThreadPool`은 무거운 프로덕션 서버에 좋지 않다. 왜냐하면 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임한다.

가용 스레드가 없다면 새로 생성한다.

무거운 프로덕션 서버는 스레드 개수를 고정한 `Executors.newFixedThreadPool`를 선택하거나, `ThreadPoolExecutor`를 직접사용하는 편이 낫다.

## 실행자 프레임워크의 이점

작업 큐를 직접 만들거나, 스레드를 직접 다루는 것은 삼가해야 한다.

직접 다루면 `Thread`가 작업 단위와 수행 메커니즘을 모두 수행하게 된다. 실행자 프레임워크를 사용하면 두 가지를 분리할 수 있다.

작업 단위를 나타내는 핵심 추상 개념은 **태스크**이다.

태스크에는 `Runnable`과 `Callable`이 있다.

태스크 수행을 실행자 서비스에 맡기면 태스크 수행 정책을 선택할 수 있고, 언제든 수정할 수 있다.

자바는 포크조인태스크를 지원하도록 확장되어 있다.

> `ForkJoinTask`의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리하고, 
> 일이 끝난 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수 있다.<br>
> 결론 : 모든 스레드가 바쁘게 움직여 CPU를 최대한 활용하여 높은 처리량과 낮은 지연시간 달성
{: .prompt-info }

포크-조인 태스크를 직접 작성, 튜닝하기 어렵지만 포크-조인 풀을 이용해만든 병렬 스트림을 이용하면 적은 노력으로 이점을 얻을 수 있다.